// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// User Model - Authentication and preferences
model User {
  id                 String    @id @default(cuid())
  email              String    @unique
  password           String
  name               String
  surname            String?
  nickname           String?
  theme              Theme     @default(DARK)
  dateFormat         DateFormat @default(MDY)
  emailVerified      Boolean   @default(false)
  emailVerifyToken   String?   @unique
  emailVerifyExpires DateTime?
  emailVerifySentAt  DateTime?
  passwordResetToken   String?   @unique
  passwordResetExpires DateTime?
  passwordResetSentAt  DateTime?
  lastLoginAt        DateTime?
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  // Relations
  people            Person[]
  groups            Group[]
  relationshipTypes RelationshipType[]
  subscription      Subscription?

  @@map("users")
}

// Person Model - Core entity representing people in the user's network
model Person {
  id                          String                @id @default(cuid())
  userId                      String
  name                        String
  surname                     String?
  nickname                    String?
  lastContact                 DateTime?
  notes                       String?               @db.Text
  relationshipToUserId        String?               // Relationship from user to this person (nullable for indirect connections)
  contactReminderEnabled      Boolean               @default(false)
  contactReminderInterval     Int?
  contactReminderIntervalUnit ReminderIntervalUnit?
  lastContactReminderSent     DateTime?
  createdAt                   DateTime              @default(now())
  updatedAt                   DateTime              @updatedAt
  deletedAt                   DateTime?

  // Relations
  user               User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  relationshipToUser RelationshipType? @relation("UserRelationship", fields: [relationshipToUserId], references: [id])
  groups             PersonGroup[]
  relationshipsFrom  Relationship[]    @relation("PersonRelationships")
  relationshipsTo    Relationship[]    @relation("RelatedPersonRelationships")
  importantDates     ImportantDate[]

  @@index([userId])
  @@index([relationshipToUserId])
  @@index([userId, lastContact]) // For recent contacts query
  @@index([userId, name]) // For name sorting/search
  @@index([userId, surname]) // For surname sorting/search
  @@index([userId, nickname]) // For nickname sorting/search
  @@index([contactReminderEnabled, lastContact]) // For contact reminder queries
  @@index([userId, deletedAt]) // For soft delete filtering
  @@map("people")
}

// Group Model - User-defined categories for organizing people
model Group {
  id          String    @id @default(cuid())
  userId      String
  name        String
  description String?
  color       String?   // Hex color for UI visualization
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?

  // Relations
  user   User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  people PersonGroup[]

  @@index([userId])
  @@index([userId, deletedAt]) // For soft delete filtering
  @@map("groups")
}

// PersonGroup - Many-to-many join table between Person and Group
model PersonGroup {
  personId String
  groupId  String
  addedAt  DateTime @default(now())

  // Relations
  person Person @relation(fields: [personId], references: [id], onDelete: Cascade)
  group  Group  @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@id([personId, groupId])
  @@index([personId])
  @@index([groupId])
  @@map("person_groups")
}

// Relationship Model - Connections between people
model Relationship {
  id                 String            @id @default(cuid())
  personId           String
  relatedPersonId    String
  relationshipTypeId String?
  notes              String?
  createdAt          DateTime          @default(now())
  updatedAt          DateTime          @updatedAt
  deletedAt          DateTime?

  // Relations
  person           Person            @relation("PersonRelationships", fields: [personId], references: [id], onDelete: Cascade)
  relatedPerson    Person            @relation("RelatedPersonRelationships", fields: [relatedPersonId], references: [id], onDelete: Cascade)
  relationshipType RelationshipType? @relation(fields: [relationshipTypeId], references: [id])

  @@index([personId])
  @@index([relatedPersonId])
  @@index([relationshipTypeId])
  @@index([personId, deletedAt]) // For soft delete filtering
  @@map("relationships")
}

// ImportantDate Model - Important dates for a person (birthdays, anniversaries, etc.)
model ImportantDate {
  id                   String                @id @default(cuid())
  personId             String
  title                String                // e.g., "Birthday", "Anniversary", "First met"
  date                 DateTime
  reminderEnabled      Boolean               @default(false)
  reminderType         ReminderType?
  reminderInterval     Int?                  // For recurring reminders
  reminderIntervalUnit ReminderIntervalUnit? // For recurring reminders
  lastReminderSent     DateTime?             // Track when last reminder was sent
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt
  deletedAt            DateTime?

  // Relations
  person Person @relation(fields: [personId], references: [id], onDelete: Cascade)

  @@index([personId])
  @@index([personId, date]) // For sorting by date
  @@index([reminderEnabled, date]) // For querying due reminders
  @@index([personId, deletedAt]) // For soft delete filtering
  @@map("important_dates")
}

enum ReminderType {
  ONCE
  RECURRING
}

enum ReminderIntervalUnit {
  DAYS
  WEEKS
  MONTHS
  YEARS
}

// RelationshipType Model - User-defined relationship types
model RelationshipType {
  id          String         @id @default(cuid())
  userId      String         // Owner of this relationship type
  name        String         // Unique identifier (PARENT, CHILD, etc.)
  label       String         // Display name
  color       String?        // Hex color for UI
  inverseId   String?        // ID of the inverse relationship type
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  deletedAt   DateTime?

  // Relations
  user                User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  inverse             RelationshipType?  @relation("InverseRelationship", fields: [inverseId], references: [id], onDelete: SetNull)
  inverseOf           RelationshipType[] @relation("InverseRelationship")
  relationships       Relationship[]
  peopleWithRelation  Person[]           @relation("UserRelationship")

  @@index([userId])
  @@index([userId, deletedAt]) // For soft delete filtering
  @@map("relationship_types")
}

// Enums
enum Theme {
  LIGHT
  DARK
}

enum DateFormat {
  MDY // MM/DD/YYYY (e.g., 12/31/2024)
  DMY // DD/MM/YYYY (e.g., 31/12/2024)
  YMD // YYYY-MM-DD (e.g., 2024-12-31)
}

// ============================================
// BILLING & SUBSCRIPTION MODELS
// ============================================

enum SubscriptionTier {
  FREE
  PERSONAL
  PRO
}

enum BillingFrequency {
  MONTHLY
  YEARLY
}

enum SubscriptionStatus {
  ACTIVE
  CANCELED
  PAST_DUE
  UNPAID
  PAUSED
}

enum PromotionDurationType {
  FIXED    // Has specific start/end dates
  RELATIVE // Duration calculated from activation (e.g., 30 days)
  FOREVER  // Never expires
}

enum PaymentStatus {
  PENDING
  SUCCEEDED
  FAILED
  REFUNDED
  CANCELED
}

// Subscription Model - One-to-one with User
model Subscription {
  id                   String             @id @default(cuid())
  userId               String             @unique
  tier                 SubscriptionTier   @default(FREE)
  status               SubscriptionStatus @default(ACTIVE)
  billingFrequency     BillingFrequency?  // NULL for free tier
  tierStartedAt        DateTime           @default(now())

  // Stripe fields
  stripeCustomerId     String?            @unique
  stripeSubscriptionId String?            @unique
  stripePriceId        String?

  // Billing period
  currentPeriodStart   DateTime?
  currentPeriodEnd     DateTime?
  cancelAtPeriodEnd    Boolean            @default(false)

  // Complimentary access (free PRO access for friends/family)
  isComplimentary      Boolean            @default(false)

  createdAt            DateTime           @default(now())
  updatedAt            DateTime           @updatedAt

  // Relations
  user                 User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  promotion            UserPromotion?
  paymentHistory       PaymentHistory[]

  @@index([stripeCustomerId])
  @@index([stripeSubscriptionId])
  @@map("subscriptions")
}

// Promotion Model - Admin-managed discount codes
model Promotion {
  id                 String                @id @default(cuid())
  code               String                @unique // e.g., "LAUNCH20", "FRIEND50"
  description        String
  discountPercent    Int                   // 0-100

  // Duration type: fixed dates or relative
  durationType       PromotionDurationType

  // For FIXED duration type
  fixedStartDate     DateTime?
  fixedEndDate       DateTime?

  // For RELATIVE duration type (e.g., "30 days from activation")
  relativeDays       Int?

  // Limits
  maxRedemptions     Int?                  // NULL = unlimited
  currentRedemptions Int                   @default(0)

  // Status
  isActive           Boolean               @default(true)

  // Stripe coupon reference (for Stripe-side discounts)
  stripeCouponId     String?               @unique

  createdAt          DateTime              @default(now())
  updatedAt          DateTime              @updatedAt

  // Relations
  userPromotions     UserPromotion[]

  @@map("promotions")
}

// UserPromotion Model - User's active promotion (one per subscription)
model UserPromotion {
  id             String       @id @default(cuid())
  subscriptionId String       @unique // One promotion per subscription
  promotionId    String
  activatedAt    DateTime     @default(now())

  // Relations
  subscription   Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  promotion      Promotion    @relation(fields: [promotionId], references: [id], onDelete: Restrict)

  @@index([promotionId])
  @@map("user_promotions")
}

// PaymentHistory Model - Record of all payments
model PaymentHistory {
  id                    String        @id @default(cuid())
  subscriptionId        String

  // Stripe data
  stripePaymentIntentId String?       @unique
  stripeInvoiceId       String?       @unique

  // Payment details
  amount                Int           // In cents
  currency              String        @default("usd")
  status                PaymentStatus
  description           String?

  // Original price before discount
  originalAmount        Int?
  discountAmount        Int?
  promotionCode         String?       // Snapshot of promo code used

  // Timestamps
  paidAt                DateTime?
  createdAt             DateTime      @default(now())

  // Relations
  subscription          Subscription  @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  @@index([subscriptionId])
  @@index([createdAt])
  @@map("payment_history")
}

// ============================================
// ADMIN & MONITORING MODELS
// ============================================

// CronJobLog Model - Track cron job executions
model CronJobLog {
  id         String   @id @default(cuid())
  jobName    String   // e.g., "send-reminders", "purge-deleted"
  status     String   // "started", "completed", "failed"
  message    String?
  executedAt DateTime @default(now())
  duration   Int?     // Duration in milliseconds

  @@index([jobName, executedAt])
  @@map("cron_job_logs")
}

// AdminAuditLog Model - Track admin panel actions
model AdminAuditLog {
  id         String   @id @default(cuid())
  action     String   // "user.update", "promo.create", "recovery.restore"
  targetType String   // "user", "person", "promotion"
  targetId   String
  details    Json?    // Before/after values
  adminEmail String
  ipAddress  String?
  createdAt  DateTime @default(now())

  @@index([action, createdAt])
  @@index([targetType, targetId])
  @@map("admin_audit_logs")
}
